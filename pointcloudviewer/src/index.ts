import { app, BrowserWindow, ipcMain, dialog, protocol } from 'electron';
import * as fs from 'fs';
import * as path from 'path';
import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 720,
    width: 1680,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      webSecurity: false, // Allow loading local resources
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// Track temp PLY files for cleanup on app exit
const tempPlyFiles: string[] = [];

// Track live capture Python bridge process
let captureProc: ChildProcessWithoutNullStreams | null = null;
let captureStdoutBuffer = '';

// Register protocols as privileged before app is ready
protocol.registerSchemesAsPrivileged([
  {
    scheme: 'safe-file',
    privileges: {
      bypassCSP: true,
      supportFetchAPI: true,
      corsEnabled: true,
      standard: true,
      secure: true,
    },
  },
  {
    scheme: 'file',
    privileges: {
      bypassCSP: true,
      supportFetchAPI: true,
      corsEnabled: true,
      standard: true,
      secure: true,
    },
  },
]);

// Register custom protocol to serve local files
app.whenReady().then(() => {
  // Register the safe-file protocol
  protocol.registerFileProtocol('safe-file', (request, callback) => {
    const url = request.url.replace('safe-file://', '');
    try {
      return callback(decodeURIComponent(url));
    } catch (error) {
      console.error('Error loading file:', error);
      return callback({ error: -2 }); // net::FAILED
    }
  });

  // Register the file protocol
  protocol.registerFileProtocol('file', (request, callback) => {
    const url = request.url.replace('file://', '');
    try {
      return callback(decodeURIComponent(url));
    } catch (error) {
      console.error('Error loading file:', error);
      return callback({ error: -2 }); // net::FAILED
    }
  });

  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// IPC Handlers for File System Operations
interface FileInfo {
  name: string;
  path: string;
  isDirectory: boolean;
  size?: number;
  modified?: Date;
}

// Helper to get backend root (where live_capture_bridge.py resides)
const getBackendRoot = (): string => {
  // app.getAppPath() points at the pointcloudviewer app root; backend is a
  // sibling folder at the workspace level.
  const appRoot = app.getAppPath();
  return path.resolve(appRoot, '..', 'backend');
};

// Live capture: start Python bridge in desired mode
ipcMain.handle('capture:start', async (_event, mode: 'gopro' | 'gopro_helios', previewOnly: boolean) => {
  if (captureProc) {
    return; // already running
  }

  const backendRoot = getBackendRoot();
  const scriptPath = path.join(backendRoot, 'live_capture_bridge.py');

  if (!fs.existsSync(scriptPath)) {
    console.error('live_capture_bridge.py not found at', scriptPath);
    return;
  }

  const args: string[] = [scriptPath, `--mode=${mode}`];

  if (previewOnly) {
    args.push('--preview-only');
  } else {
    // Allow overriding backend URL for cloud-hosted backends via env var
    const backendWsUrl = process.env.BACKEND_WS_URL;
    if (backendWsUrl) {
      args.push(`--backend-url=${backendWsUrl}`);
    }
  }

  captureProc = spawn('python3', args, {
    cwd: backendRoot,
    stdio: ['pipe', 'pipe', 'pipe'],
  });

  captureProc.stdout.on('data', (chunk: Buffer) => {
    const text = chunk.toString('utf8');
    captureStdoutBuffer += text;

    const parts = captureStdoutBuffer.split('\n');
    // Keep the last partial line in the buffer
    captureStdoutBuffer = parts.pop() ?? '';

    for (const line of parts) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      try {
        const msg = JSON.parse(trimmed);
        BrowserWindow.getAllWindows().forEach((win) => {
          win.webContents.send('capture:frame', msg);
        });
      } catch (e) {
        console.error('Failed to parse capture bridge output:', e);
      }
    }
  });

  captureProc.stderr.on('data', (chunk: Buffer) => {
    console.error('capture bridge stderr:', chunk.toString());
  });

  captureProc.on('exit', (code, signal) => {
    console.log('capture bridge exited with code', code, 'signal', signal);
    captureProc = null;
    captureStdoutBuffer = '';
  });
});

// Live capture: stop Python bridge
ipcMain.handle('capture:stop', async () => {
  if (captureProc) {
    try {
      // Send SIGINT so the bridge can clean up (stop webcam
      // mode and return GoPro to regular video) before exiting.
      captureProc.kill('SIGINT');
    } catch (e) {
      console.error('Failed to kill capture bridge:', e);
    }
    captureProc = null;
  }
});

// Open directory picker dialog
ipcMain.handle('dialog:openDirectory', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openDirectory']
  });

  if (result.canceled || result.filePaths.length === 0) {
    return null;
  }

  return result.filePaths[0];
});

// Open GLB file picker dialog
ipcMain.handle('dialog:openGLBFile', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [
      { name: '3D Models', extensions: ['glb'] }
    ]
  });

  if (result.canceled || result.filePaths.length === 0) {
    return null;
  }

  return result.filePaths[0];
});

// Open PCD file picker dialog
ipcMain.handle('dialog:openPCDFile', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [
      { name: 'Point Cloud Data', extensions: ['pcd'] }
    ]
  });

  if (result.canceled || result.filePaths.length === 0) {
    return null;
  }

  return result.filePaths[0];
});

// Open PLY file picker dialog
ipcMain.handle('dialog:openPLYFile', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [
      { name: 'Polygon File Format', extensions: ['ply'] }
    ]
  });

  if (result.canceled || result.filePaths.length === 0) {
    return null;
  }

  return result.filePaths[0];
});

// Read directory contents
ipcMain.handle('fs:readDirectory', async (_event, dirPath: string): Promise<FileInfo[]> => {
  try {
    const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });

    const fileInfos: FileInfo[] = await Promise.all(
      entries.map(async (entry) => {
        const fullPath = path.join(dirPath, entry.name);
        const stats = await fs.promises.stat(fullPath);

        return {
          name: entry.name,
          path: fullPath,
          isDirectory: entry.isDirectory(),
          size: stats.size,
          modified: stats.mtime
        };
      })
    );

    // Sort: directories first, then files, alphabetically
    return fileInfos.sort((a, b) => {
      if (a.isDirectory === b.isDirectory) {
        return a.name.localeCompare(b.name);
      }
      return a.isDirectory ? -1 : 1;
    });
  } catch (error) {
    console.error('Error reading directory:', error);
    return [];
  }
});

// Get file stats
ipcMain.handle('fs:getStats', async (_event, filePath: string) => {
  try {
    const stats = await fs.promises.stat(filePath);
    return {
      size: stats.size,
      isDirectory: stats.isDirectory(),
      isFile: stats.isFile(),
      modified: stats.mtime,
      created: stats.birthtime
    };
  } catch (error) {
    console.error('Error getting file stats:', error);
    return null;
  }
});

// Check if a directory is a scene folder
ipcMain.handle('fs:checkSceneFolder', async (_event, dirPath: string): Promise<boolean> => {
  try {
    const entries = await fs.promises.readdir(dirPath);
    const folderName = path.basename(dirPath);

    // Required files
    const requiredFiles = [
      'scene.glb',
      'scene_graph.json',
      'qa_pairs.json',
      'image_reference_mappings.json'
    ];

    // Check if all required files exist
    const hasAllFiles = requiredFiles.every(file => entries.includes(file));

    // Check for images directory
    const hasImagesDir = entries.includes('images');
    if (hasImagesDir) {
      const imagesPath = path.join(dirPath, 'images');
      const imagesStat = await fs.promises.stat(imagesPath);
      if (!imagesStat.isDirectory()) {
        return false;
      }
    } else {
      return false;
    }

    // Check for PDF with matching folder name
    const pdfFile = entries.find(file =>
      file.endsWith('.pdf') && file.replace('.pdf', '') === folderName
    );

    return hasAllFiles && hasImagesDir && !!pdfFile;
  } catch (error) {
    console.error('Error checking scene folder:', error);
    return false;
  }
});

// Get Downloads folder path
ipcMain.handle('fs:getDownloadsPath', async (): Promise<string | null> => {
  try {
    const downloadsPath = app.getPath('downloads');
    // Check if the directory exists
    await fs.promises.access(downloadsPath);
    return downloadsPath;
  } catch (error) {
    console.error('Error getting downloads path:', error);
    return null;
  }
});

// Get PDF path from scene folder path
ipcMain.handle('fs:getScenePDFPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const folderName = path.basename(scenePath);
    const pdfPath = path.join(scenePath, `${folderName}.pdf`);

    // Verify the file exists
    await fs.promises.access(pdfPath);
    return pdfPath;
  } catch (error) {
    console.error('Error getting scene PDF path:', error);
    return null;
  }
});

// Get GLB path from scene folder path
ipcMain.handle('fs:getSceneGLBPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const glbPath = path.join(scenePath, 'scene.glb');

    // Verify the file exists
    await fs.promises.access(glbPath);
    return glbPath;
  } catch (error) {
    console.error('Error getting scene GLB path:', error);
    return null;
  }
});

// Get QA pairs path from scene folder path
ipcMain.handle('fs:getSceneQAPairsPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const qaPairsPath = path.join(scenePath, 'qa_pairs.json');

    // Verify the file exists
    await fs.promises.access(qaPairsPath);
    return qaPairsPath;
  } catch (error) {
    console.error('Error getting scene QA pairs path:', error);
    return null;
  }
});

// Read and parse QA pairs JSON file
ipcMain.handle('fs:readQAPairs', async (_event, qaPairsPath: string): Promise<any[] | null> => {
  try {
    const fileContent = await fs.promises.readFile(qaPairsPath, 'utf-8');
    const qaPairs = JSON.parse(fileContent);
    return qaPairs;
  } catch (error) {
    console.error('Error reading QA pairs file:', error);
    return null;
  }
});

// Get scene graph JSON file path
ipcMain.handle('fs:getSceneGraphPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const sceneGraphPath = path.join(scenePath, 'scene_graph.json');

    // Verify the file exists
    await fs.promises.access(sceneGraphPath);
    return sceneGraphPath;
  } catch (error) {
    console.error('Error getting scene graph path:', error);
    return null;
  }
});

// Read and parse scene graph JSON file
ipcMain.handle('fs:readSceneGraph', async (_event, sceneGraphPath: string): Promise<any | null> => {
  try {
    const fileContent = await fs.promises.readFile(sceneGraphPath, 'utf-8');
    const sceneGraph = JSON.parse(fileContent);
    return sceneGraph;
  } catch (error) {
    console.error('Error reading scene graph file:', error);
    return null;
  }
});

// Get image file paths from scene folder's images directory
ipcMain.handle('fs:getSceneImages', async (_event, scenePath: string): Promise<string[] | null> => {
  try {
    const imagesDir = path.join(scenePath, 'images');

    // Verify the directory exists
    await fs.promises.access(imagesDir);

    // Read directory contents
    const entries = await fs.promises.readdir(imagesDir, { withFileTypes: true });

    // Filter for image files (png, jpg, jpeg)
    const imageFiles = entries
      .filter(entry => {
        if (!entry.isFile()) return false;
        const ext = path.extname(entry.name).toLowerCase();
        return ['.png', '.jpg', '.jpeg'].includes(ext);
      })
      .map(entry => path.join(imagesDir, entry.name))
      .sort(); // Sort alphabetically

    return imageFiles;
  } catch (error) {
    console.error('Error getting scene images:', error);
    return null;
  }
});

// Chat IPC Handlers for FastAPI communication
interface ChatResponse {
  message?: string;
  content?: string;
  error?: string;
  command?: {
    type: string;
    action: string;
    params?: Record<string, unknown>;
  };
}

// Send message to FastAPI backend
ipcMain.handle('chat:sendMessage', async (_event, message: string, endpoint: string = 'http://localhost:8000'): Promise<ChatResponse> => {
  try {
    // Use Node's native fetch (available in Electron 22+)
    const response = await fetch(`${endpoint}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ message }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json() as ChatResponse;
    return data;
  } catch (error) {
    console.error('Error sending chat message:', error);
    return {
      error: error instanceof Error ? error.message : 'Failed to connect to backend',
    };
  }
});

// Save a PLY blob to a temporary file on disk and return the path.
ipcMain.handle('fs:saveTempPLY', async (_event, data: Buffer): Promise<string | null> => {
  try {
    const tmpDir = app.getPath('temp');
    const fileName = `vggt_submap_${Date.now()}_${Math.random().toString(36).slice(2)}.ply`;
    const fullPath = path.join(tmpDir, fileName);
    await fs.promises.writeFile(fullPath, data);
    // Remember for cleanup when the app exits
    tempPlyFiles.push(fullPath);
    return fullPath;
  } catch (error) {
    console.error('Error saving temp PLY:', error);
    return null;
  }
});

// Cleanup temp PLY files on app quit to avoid buildup
app.on('before-quit', async () => {
  if (tempPlyFiles.length === 0) return;
  try {
    await Promise.all(
      tempPlyFiles.map(async (filePath) => {
        try {
          await fs.promises.unlink(filePath);
        } catch (err) {
          // Ignore missing files or deletion errors
        }
      })
    );
  } catch {
    // Best-effort cleanup only
  }
});

// Export all stored submap PLYs into a folder under Downloads and return the folder path.
ipcMain.handle('fs:exportSubmaps', async (_event, srcPaths: string[]): Promise<string | null> => {
  try {
    if (!srcPaths || srcPaths.length === 0) return null;
    const downloadsPath = app.getPath('downloads');
    const outDir = path.join(downloadsPath, `vggt_submaps_${Date.now()}`);
    await fs.promises.mkdir(outDir, { recursive: true });

    await Promise.all(
      srcPaths.map(async (src, idx) => {
        if (!src) return;
        const baseName = path.basename(src) || `submap_${idx + 1}.ply`;
        const dest = path.join(outDir, baseName);
        try {
          await fs.promises.copyFile(src, dest);
        } catch (err) {
          console.error('Error copying submap PLY:', err);
        }
      })
    );

    return outDir;
  } catch (error) {
    console.error('Error exporting submaps:', error);
    return null;
  }
});
