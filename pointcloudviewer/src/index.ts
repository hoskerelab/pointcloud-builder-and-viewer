import { app, BrowserWindow, ipcMain, dialog, protocol, session, crashReporter, nativeImage } from 'electron';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { spawn } from 'child_process';
import { createHash } from 'crypto';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// --- ADD THIS BLOCK AT THE TOP ---
console.log('--- [MAIN PROCESS] SCRIPT START ---');
try {
  console.log(`[Main] __dirname: ${__dirname}`);
  console.log(`[Main] __filename: ${__filename}`);
} catch (e) {
  console.log(`[Main] __dirname or __filename is not defined at top level.`);
}
console.log(`[Main] !app.isPackaged: ${!app.isPackaged}`);
// --- END BLOCK ---

const enableVerboseLogging = process.env.ELECTRON_VERBOSE_LOGGING === '1';
if (enableVerboseLogging) {
  app.commandLine.appendSwitch('enable-logging');
  app.commandLine.appendSwitch('v', '1');
  console.log('[Main] Verbose logging enabled via ELECTRON_VERBOSE_LOGGING=1');
}

// Prefer the discrete/high-performance GPU when available.
app.commandLine.appendSwitch('force_high_performance_gpu');

process.on('uncaughtException', (error) => {
  console.error('[Main] uncaughtException:', error);
});

process.on('unhandledRejection', (reason) => {
  console.error('[Main] unhandledRejection:', reason);
});

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  const isDev = !app.isPackaged;

  // --- REPLACE YOUR EXISTING DEBUG BLOCK WITH THIS ---
  console.log('--- [MAIN PROCESS] CREATING WINDOW ---');
  
  console.log('--- [MAIN PROCESS] DUMPING ENV VARS ---');
  console.log(`[Main] process.env.PORT: ${process.env.PORT}`);
  console.log(`[Main] process.env.WEBPACK_DEV_SERVER_PORT: ${process.env.WEBPACK_DEV_SERVER_PORT}`);
  console.log(`[Main] process.env.WEBPACK_DEV_SERVER_URL: ${process.env.WEBPACK_DEV_SERVER_URL}`);
  
  console.log(`[Main] isDev: ${isDev}`);
  console.log(`[Main] MAIN_WINDOW_WEBPACK_ENTRY: ${MAIN_WINDOW_WEBPACK_ENTRY}`);
  console.log(`[Main] MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: ${MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY}`);

  const webPreferences = {
    preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    contextIsolation: true,
    sandbox: false,
    nodeIntegration: false,
    nodeIntegrationInWorker: false,
    webSecurity: false, // Just for development; relaxes CORS and CSP
  };

  console.log('[Main] Final webPreferences:');
  console.log(JSON.stringify(webPreferences, null, 2));
  // --- END BLOCK ---

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 720,
    width: 1680,
    webPreferences, // <-- Use the new object here
  });

  // and load the index.html of the app.
  let entryUrl = MAIN_WINDOW_WEBPACK_ENTRY;
  // DEBUG: This override was causing issues. Don't fight forge.
  // if (entryUrl.includes('localhost:3000')) {
  //   console.warn('[Main] Detected legacy dev server on port 3000; defaulting to webpack dev server on 9000.');
  //   entryUrl = entryUrl.replace('localhost:3000', 'localhost:9000');
  // }

// Manually specify the URL to load
// const entryUrl = 'http://localhost:9000/main_window/index.html';
// const entryUrl = 'http://localhost:9000';
// const entryUrl = 'http://localhost:9000/main_window';
// const entryUrl = 'http://localhost:9000/main_window.html';

  // Debug log for URL being loaded
  console.log('[Main] will load URL', entryUrl);
  console.log('[Main] ELECTRON_START_URL', process.env.ELECTRON_START_URL);
  mainWindow.loadURL(entryUrl);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// Register protocols as privileged before app is ready
protocol.registerSchemesAsPrivileged([
  {
    scheme: 'safe-file',
    privileges: {
      bypassCSP: true,
      supportFetchAPI: true,
      corsEnabled: true,
      standard: true,
      secure: true,
    },
  },
  {
    scheme: 'file',
    privileges: {
      bypassCSP: true,
      supportFetchAPI: true,
      corsEnabled: true,
      standard: true,
      secure: true,
    },
  },
]);

// Register custom protocol to serve local files
app.whenReady().then(() => {
  // --- ADD THIS LOG ---
  console.log('[Main] app.whenReady(): Registering file protocols.');
  // --- END LOG ---

  if (enableVerboseLogging) {
    crashReporter.start({
      uploadToServer: false,
      compress: false,
    });
    console.log(`[Main] crashReporter started. crashDumps: ${app.getPath('crashDumps')}`);
  }

  const s = session.defaultSession;

  // Log current headers (optional)
  s.webRequest.onHeadersReceived((details, callback) => {
    const rh = details.responseHeaders || {};
    const key = Object.keys(rh).find(k => k.toLowerCase() === 'content-security-policy');

    // DEV-ONLY: replace CSP for localhost:3000 (your dev server)
    try {
      const u = new URL(details.url);
      if (u.origin === 'http://localhost:3000') {
        rh['Content-Security-Policy'] = [[
          "default-src 'self' data: blob: 'unsafe-inline' 'unsafe-eval'",
          "script-src 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval'",
          "style-src 'self' 'unsafe-inline'",
          "img-src 'self' data: blob:",
          "font-src 'self' data:",
          "connect-src * ws://* http://* https://*",
          "worker-src 'self' blob:",
          "object-src 'none'"
        ].join('; ')];
      }
    } catch {}

    callback({ responseHeaders: rh });
  });


  // Register the safe-file protocol
  const safeFileUrlToPath = (requestUrl: string): string => {
    // Robust parsing that handles:
    //   1. safe-file:///C:/Users/... (Correct)
    //   2. safe-file://c/Users/...   (Chrome Normalized "Windows Bug")
    //   3. safe-file://Users/...     (Mac)
    try {
      const u = new URL(requestUrl);

      // --- WINDOWS SPECIFIC LOGIC ---
      if (process.platform === "win32") {
        // CASE 1: Chrome treated drive letter as hostname (e.g. safe-file://c/Users/...)
        // u.hostname = "c"
        if (u.hostname && u.hostname.length === 1) {
          const drive = u.hostname.toUpperCase();
          const p = decodeURIComponent(u.pathname || "");
          // Result: C:\Users\path...
          return `${drive}:${p}`.replace(/\//g, "\\");
        }

        // CASE 2: Correct URL (e.g. safe-file:///C:/Users/...)
        // u.hostname = ""
        // u.pathname = "/C:/Users/..."
        const p = decodeURIComponent(u.pathname || "");
        if (/^\/[A-Za-z]:\//.test(p)) {
          // Remove leading slash -> "C:/Users/..." -> "C:\Users\..."
          return p.slice(1).replace(/\//g, "\\");
        }
      }

      // --- MAC / LINUX LOGIC ---
      // CASE 3: Standard Mac path (e.g. safe-file:///Users/jg...)
      // u.hostname = ""
      // u.pathname = "/Users/jg..."
      if (!u.hostname) {
        return decodeURIComponent(u.pathname);
      }

      // CASE 4: Malformed Mac path (e.g. safe-file://Users/jg...)
      // u.hostname = "Users"
      // u.pathname = "/jg..."
      return decodeURIComponent(`/${u.hostname}${u.pathname}`);

    } catch (e) {
      console.error("Path parsing failed:", e);
    }

    // Last resort fallback (manual string manipulation)
    return decodeURIComponent(requestUrl.replace(/^safe-file:\/\//, ""));
  };
  
  protocol.registerFileProtocol('safe-file', (request, callback) => {
    const url = safeFileUrlToPath(request.url);
    try {
      return callback(url);
    } catch (error) {
      console.error('Error loading file:', error);
      return callback({ error: -2 }); // net::FAILED
    }
  });

  // Register the file protocol
  protocol.registerFileProtocol('file', (request, callback) => {
    const url = request.url.replace('file://', '');
    try {
      return callback(decodeURIComponent(url));
    } catch (error) {
      console.error('Error loading file:', error);
      return callback({ error: -2 }); // net::FAILED
    }
  });

  createWindow();
  
});

app.on('render-process-gone', (_event, _webContents, details) => {
  console.error('[Main] render-process-gone:', details);
});

app.on('child-process-gone', (_event, details) => {
  console.error('[Main] child-process-gone:', details);
});

app.on('gpu-process-crashed', (_event, killed) => {
  console.error('[Main] gpu-process-crashed. killed:', killed);
});

app.on('web-contents-created', (_event, contents) => {
  contents.on('did-fail-load', (_e, errorCode, errorDesc, validatedURL) => {
    console.error('[Main] did-fail-load:', { errorCode, errorDesc, validatedURL });
  });

  contents.on('render-process-gone', (_e, details) => {
    console.error('[Main] webContents render-process-gone:', details);
  });

  contents.on('unresponsive', () => {
    console.error('[Main] webContents unresponsive');
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// IPC Handlers for File System Operations
interface FileInfo {
  name: string;
  path: string;
  isDirectory: boolean;
  size?: number;
  modified?: Date;
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.promises.access(filePath);
    return true;
  } catch {
    return false;
  }
}

ipcMain.handle('app:getPath', () => app.getAppPath());

ipcMain.handle('path:join', (_event, parts: string[]) => path.join(...parts));

// Open directory picker dialog
ipcMain.handle('dialog:openDirectory', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openDirectory']
  });

  if (result.canceled || result.filePaths.length === 0) {
    return null;
  }

  return result.filePaths[0];
});

// Open GLB file picker dialog
ipcMain.handle('dialog:openGLBFile', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [
      { name: '3D Models', extensions: ['glb'] }
    ]
  });

  if (result.canceled || result.filePaths.length === 0) {
    return null;
  }

  return result.filePaths[0];
});

// Read directory contents
ipcMain.handle('fs:readDirectory', async (_event, dirPath: string): Promise<FileInfo[]> => {
  try {
    const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });

    const fileInfos: FileInfo[] = await Promise.all(
      entries.map(async (entry) => {
        const fullPath = path.join(dirPath, entry.name);
        const stats = await fs.promises.stat(fullPath);

        return {
          name: entry.name,
          path: fullPath,
          isDirectory: entry.isDirectory(),
          size: stats.size,
          modified: stats.mtime
        };
      })
    );

    // Sort: directories first, then files, alphabetically
    return fileInfos.sort((a, b) => {
      if (a.isDirectory === b.isDirectory) {
        return a.name.localeCompare(b.name);
      }
      return a.isDirectory ? -1 : 1;
    });
  } catch (error) {
    console.error('Error reading directory:', error);
    return [];
  }
});

// Get file stats
ipcMain.handle('fs:getStats', async (_event, filePath: string) => {
  try {
    const stats = await fs.promises.stat(filePath);
    return {
      size: stats.size,
      isDirectory: stats.isDirectory(),
      isFile: stats.isFile(),
      modified: stats.mtime,
      created: stats.birthtime
    };
  } catch (error) {
    console.error('Error getting file stats:', error);
    return null;
  }
});

// Check if a directory is a scene folder
ipcMain.handle('fs:checkSceneFolder', async (_event, dirPath: string): Promise<boolean> => {
  try {
    const entries = await fs.promises.readdir(dirPath);
    const folderName = path.basename(dirPath);

    // Required files
    const requiredFiles = [
      'metadata.json',
      'point_cloud.glb',
      // 'point_cloud.ply',
      'camera_extrinsics.npy',
      // 'pose_encoding.npy',
      'camera_intrinsics.npy'
    ];

    const entriesSet = new Set(entries);

    // Verify required files exist
    const hasAllRequired = requiredFiles.every(file => entriesSet.has(file));
    if (!hasAllRequired) {
      return false;
    }

    // Check for images directory
    if (!entriesSet.has('images')) {
      return false;
    }

    const imagesPath = path.join(dirPath, 'images');
    const imagesStat = await fs.promises.stat(imagesPath);
    if (!imagesStat.isDirectory()) {
      return false;
    }

    return true;
  } catch (error) {
    console.error('Error checking scene folder:', error);
    return false;
  }
});

// Get Downloads folder path
ipcMain.handle('fs:getDownloadsPath', async (): Promise<string | null> => {
  try {
    const downloadsPath = app.getPath('downloads');
    // Check if the directory exists
    await fs.promises.access(downloadsPath);
    return downloadsPath;
  } catch (error) {
    console.error('Error getting downloads path:', error);
    return null;
  }
});

// Get PDF path from scene folder path
ipcMain.handle('fs:getScenePDFPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const folderName = path.basename(scenePath);
    const pdfPath = path.join(scenePath, `${folderName}.pdf`);

    // Verify the file exists
    await fs.promises.access(pdfPath);
    return pdfPath;
  } catch (error) {
    console.error('Error getting scene PDF path:', error);
    return null;
  }
});

// Get GLB path from scene folder path
ipcMain.handle('fs:getSceneGLBPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const preferredGlb = path.join(scenePath, 'point_cloud.glb');
    const fallbackGlb = path.join(scenePath, 'scene.glb');
    const glbPath = (await fileExists(preferredGlb)) ? preferredGlb : fallbackGlb;

    // Verify the file exists
    await fs.promises.access(glbPath);
    return glbPath;
  } catch (error) {
    console.error('Error getting scene GLB path:', error);
    return null;
  }
});

// Get QA pairs path from scene folder path
ipcMain.handle('fs:getSceneQAPairsPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const qaPairsPath = path.join(scenePath, 'qa_pairs.json');

    // Verify the file exists
    await fs.promises.access(qaPairsPath);
    return qaPairsPath;
  } catch (error) {
    console.error('Error getting scene QA pairs path:', error);
    return null;
  }
});

// Read and parse QA pairs JSON file
ipcMain.handle('fs:readQAPairs', async (_event, qaPairsPath: string): Promise<any[] | null> => {
  try {
    const fileContent = await fs.promises.readFile(qaPairsPath, 'utf-8');
    const qaPairs = JSON.parse(fileContent);
    return qaPairs;
  } catch (error) {
    console.error('Error reading QA pairs file:', error);
    return null;
  }
});

// Get scene graph JSON file path
ipcMain.handle('fs:getSceneGraphPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const sceneGraphPath = path.join(scenePath, 'scene_graph.json');

    // Verify the file exists
    await fs.promises.access(sceneGraphPath);
    return sceneGraphPath;
  } catch (error) {
    console.error('Error getting scene graph path:', error);
    return null;
  }
});

// Read and parse scene graph JSON file
ipcMain.handle('fs:readSceneGraph', async (_event, sceneGraphPath: string): Promise<any | null> => {
  try {
    const fileContent = await fs.promises.readFile(sceneGraphPath, 'utf-8');
    const sceneGraph = JSON.parse(fileContent);
    return sceneGraph;
  } catch (error) {
    console.error('Error reading scene graph file:', error);
    return null;
  }
});

// Get image file paths from scene folder's images directory
ipcMain.handle('fs:getSceneImages', async (_event, scenePath: string): Promise<string[] | null> => {
  try {
    const imagesDir = path.join(scenePath, 'images');

    // Verify the directory exists
    await fs.promises.access(imagesDir);

    // Read directory contents
    const entries = await fs.promises.readdir(imagesDir, { withFileTypes: true });

    // Filter for image files (png, jpg, jpeg)
    const imageFiles = entries
      .filter(entry => {
        if (!entry.isFile()) return false;
        const ext = path.extname(entry.name).toLowerCase();
        return ['.png', '.jpg', '.jpeg', '.webp', '.tiff'].includes(ext);
      })
      .map(entry => path.join(imagesDir, entry.name))
      .sort((a, b) => a.localeCompare(b));

    return imageFiles;
  } catch (error) {
    console.error('Error getting scene images:', error);
    return null;
  }
});

// Read and parse scene metadata
ipcMain.handle('fs:getSceneMetadata', async (_event, scenePath: string): Promise<any | null> => {
  try {
    const metadataPath = path.join(scenePath, 'metadata.json');
    const fileContent = await fs.promises.readFile(metadataPath, 'utf-8');
    return JSON.parse(fileContent);
  } catch (error) {
    console.error('Error reading scene metadata:', error);
    return null;
  }
});

function sanitizeFolderName(value: string) {
  return value.replace(/[<>:"/\\|?*\x00-\x1F]/g, '_').trim() || 'prompt';
}

function toDockerPath(p: string) {
  return p.replace(/\\/g, '/');
}

async function listImageFiles(dirPath: string): Promise<string[]> {
  const results: string[] = [];
  const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      results.push(...(await listImageFiles(fullPath)));
      continue;
    }
    if (!entry.isFile()) continue;
    const ext = path.extname(entry.name).toLowerCase();
    const baseName = path.basename(entry.name).toLowerCase();
    if (baseName === 'mask_merged.png') {
      continue;
    }
    if (['.png', '.jpg', '.jpeg', '.webp', '.tiff'].includes(ext)) {
      results.push(fullPath);
    }
  }

  results.sort((a, b) => {
    const aName = path.basename(a).toLowerCase();
    const bName = path.basename(b).toLowerCase();
    const aScore = aName.includes('overlay') ? 0 : aName.includes('mask') ? 1 : 2;
    const bScore = bName.includes('overlay') ? 0 : bName.includes('mask') ? 1 : 2;
    if (aScore !== bScore) return aScore - bScore;
    return a.localeCompare(b);
  });

  return results;
}

type SegmentationJob = {
  prompt: string;
  scenePath: string;
  resolve: (value: { ok: boolean; outputDir?: string; images?: string[]; error?: string }) => void;
  reject: (reason?: unknown) => void;
};

const segmentationQueue: SegmentationJob[] = [];
let segmentationRunning = false;
const segmentationContainer = {
  name: 'sam3-inference',
  scenePath: null as string | null,
  entrypoint: null as string[] | null,
  cmd: null as string[] | null,
};

async function runSegmentationJob(prompt: string, scenePath: string) {
  const inputDir = path.join(scenePath, 'images');
  const outputBaseDir = path.join(scenePath, 'segmentation');
  const outputDir = path.join(outputBaseDir, sanitizeFolderName(prompt));

  try {
    await fs.promises.access(inputDir);
  } catch {
    return { ok: false, error: 'Input image directory not found' };
  }

  await fs.promises.mkdir(outputDir, { recursive: true });

  const args = [
    'run',
    '--rm',
    '--network',
    'none',
    '--gpus',
    'all',
    '-v',
    `${toDockerPath(inputDir)}:/input:ro`,
    '-v',
    `${toDockerPath(outputBaseDir)}:/output`,
    'sam3-folder:cu128',
    '--input_dir',
    '/input',
    '--output_dir',
    `/output/${sanitizeFolderName(prompt)}`,
    '--prompt',
    prompt,
    '--confidence_threshold',
    '0.5',
    '--fp16',
  ];

  try {
    console.log('[Segmentation] docker', 'docker', args.join(' '));
    await runDocker(args, 'inherit');
    const images = await listImageFiles(outputDir);
    return { ok: true, outputDir, images };
  } catch (error) {
    console.error('[Segmentation] failed', error);
    return {
      ok: false,
      error: error instanceof Error ? error.message : 'Segmentation failed',
    };
  }
}

async function runDocker(args: string[], stdio: 'inherit' | 'pipe' = 'inherit') {
  return new Promise<{ stdout: string; stderr: string }>((resolve, reject) => {
    const proc = spawn('docker', args, { stdio: stdio === 'inherit' ? 'inherit' : ['ignore', 'pipe', 'pipe'] });
    let stdout = '';
    let stderr = '';
    if (proc.stdout) {
      proc.stdout.on('data', (data) => {
        stdout += data.toString();
      });
    }
    if (proc.stderr) {
      proc.stderr.on('data', (data) => {
        stderr += data.toString();
      });
    }
    proc.on('error', reject);
    proc.on('close', (code) => {
      if (code === 0) resolve({ stdout, stderr });
      else reject(new Error(`docker exited with code ${code}`));
    });
  });
}

async function getContainerInfo(name: string) {
  try {
    const result = await runDocker(['inspect', name], 'pipe');
    const parsed = JSON.parse(result.stdout);
    const info = parsed?.[0];
    if (!info) return { exists: false };
    return {
      exists: true,
      running: Boolean(info.State?.Running),
      labels: info.Config?.Labels || {},
    };
  } catch {
    return { exists: false };
  }
}

async function ensureSegmentationContainer(scenePath: string, inputDir: string, outputDir: string) {
  const info = await getContainerInfo(segmentationContainer.name);
  const existingScene = info.exists ? info.labels?.['sam3.scenePath'] : null;
  const needsRestart = info.exists && existingScene && existingScene !== scenePath;
  if (needsRestart) {
    try {
      await runDocker(['rm', '-f', segmentationContainer.name], 'inherit');
    } catch (error) {
      console.warn('[Segmentation] failed to remove container', error);
    }
    segmentationContainer.entrypoint = null;
    segmentationContainer.cmd = null;
  } else if (info.exists) {
    if (!info.running) {
      await runDocker(['start', segmentationContainer.name], 'inherit');
    }
    segmentationContainer.scenePath = scenePath;
  }

  if (!info.exists || needsRestart) {
    const args = [
      'run',
      '-d',
      '--name',
      segmentationContainer.name,
      '--network',
      'none',
      '--gpus',
      'all',
      '--label',
      `sam3.scenePath=${scenePath}`,
      '-v',
      `${toDockerPath(inputDir)}:/input:ro`,
      '-v',
      `${toDockerPath(outputDir)}:/output`,
      'sam3-folder:cu128',
      'sleep',
      'infinity',
    ];
    console.log('[Segmentation] starting container', 'docker', args.join(' '));
    await runDocker(args, 'inherit');
    segmentationContainer.scenePath = scenePath;
  }

  if (!segmentationContainer.entrypoint) {
    const inspect = await runDocker(['inspect', 'sam3-folder:cu128'], 'pipe');
    const parsed = JSON.parse(inspect.stdout);
    const config = parsed?.[0]?.Config || {};
    segmentationContainer.entrypoint = Array.isArray(config.Entrypoint) ? config.Entrypoint : null;
    segmentationContainer.cmd = Array.isArray(config.Cmd) ? config.Cmd : null;
  }
}

async function execSegmentation(
  prompt: string,
  outputSubdir: string
) {
  const baseCommand = segmentationContainer.entrypoint ?? segmentationContainer.cmd ?? [];
  if (baseCommand.length === 0) {
    throw new Error('Unable to determine segmentation command for docker exec');
  }
  const args = [
    'exec',
    segmentationContainer.name,
    ...baseCommand,
    '--input_dir',
    '/input',
    '--output_dir',
    `/output/${outputSubdir}`,
    '--prompt',
    prompt,
    '--confidence_threshold',
    '0.5',
    '--fp16',
  ];
  console.log('[Segmentation] exec', 'docker', args.join(' '));
  await runDocker(args, 'inherit');
}

function enqueueSegmentationJob(prompt: string, scenePath: string) {
  return new Promise<{ ok: boolean; outputDir?: string; images?: string[]; error?: string }>((resolve, reject) => {
    segmentationQueue.push({ prompt, scenePath, resolve, reject });
    void processSegmentationQueue();
  });
}

async function processSegmentationQueue() {
  if (segmentationRunning) return;
  const next = segmentationQueue.shift();
  if (!next) return;
  segmentationRunning = true;

  try {
    const result = await runSegmentationJob(next.prompt, next.scenePath);
    next.resolve(result);
  } catch (error) {
    next.reject(error);
  } finally {
    segmentationRunning = false;
    if (segmentationQueue.length > 0) {
      void processSegmentationQueue();
    }
  }
}

// Read binary file as Buffer
ipcMain.handle('fs:readFileBuffer', async (_event, filePath: string): Promise<Buffer | null> => {
  try {
    const data = await fs.promises.readFile(filePath);

    // --- Start Debug Logs ---
    if (filePath.endsWith('pose_encoding.npy')) {
        console.log(`[Main Process readFileBuffer] Read file: ${filePath}`);
        console.log(`[Main Process readFileBuffer] Buffer instance: ${data instanceof Buffer}`);
        console.log(`[Main Process readFileBuffer] Buffer length: ${data.length}`);
        const firstBytes = data.slice(0, 10);
        console.log(`[Main Process readFileBuffer] Buffer first 10 bytes (hex): ${firstBytes.toString('hex')}`);
         try {
           const firstChars = firstBytes.toString('latin1');
           console.log(`[Main Process readFileBuffer] Buffer first 10 chars (latin1): "${firstChars}"`);
         } catch (e) {
           console.error('[Main Process readFileBuffer] Error decoding first bytes as latin1:', e);
         }
    }
    // --- End Debug Logs ---

    return data;
  } catch (error) {
    console.error(`Error reading binary file: ${filePath}`, error);
    return null;
  }
});

ipcMain.handle('segmentation:run', async (_event, prompt: string, scenePath: string | null) => {
  if (!scenePath) {
    return { ok: false, error: 'No scene selected' };
  }
  return enqueueSegmentationJob(prompt, scenePath);
});

ipcMain.handle('segmentation:list', async (_event, scenePath: string | null) => {
  if (!scenePath) {
    return { ok: false, error: 'No scene selected' };
  }

  const baseDir = path.join(scenePath, 'segmentation');

  try {
    const entries = await fs.promises.readdir(baseDir, { withFileTypes: true });
    const folders = entries
      .filter((entry) => entry.isDirectory() && !entry.name.startsWith('.'))
      .map((entry) => entry.name)
      .sort((a, b) => a.localeCompare(b));

    const tabs = [];
    for (const folder of folders) {
      const folderPath = path.join(baseDir, folder);
      const images = await listImageFiles(folderPath);
      tabs.push({ label: folder, images, folderPath });
    }

    return { ok: true, tabs };
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return { ok: true, tabs: [] };
    }
    console.error('[Segmentation] list failed', error);
    return {
      ok: false,
      error: error instanceof Error ? error.message : 'Failed to load segmentation folders',
    };
  }
});

ipcMain.handle('segmentation:delete', async (_event, scenePath: string | null, label: string) => {
  if (!scenePath) {
    return { ok: false, error: 'No scene selected' };
  }

  const baseDir = path.join(scenePath, 'segmentation');
  const targetDir = path.join(baseDir, label);
  const resolvedBase = path.resolve(baseDir);
  const resolvedTarget = path.resolve(targetDir);

  if (!resolvedTarget.startsWith(resolvedBase)) {
    return { ok: false, error: 'Invalid segmentation path' };
  }

  try {
    await fs.promises.rm(resolvedTarget, { recursive: true, force: true });
    return { ok: true };
  } catch (error) {
    console.error('[Segmentation] delete failed', error);
    return {
      ok: false,
      error: error instanceof Error ? error.message : 'Failed to delete segmentation',
    };
  }
});

ipcMain.handle(
  'thumbnail:get',
  async (_event, imagePath: string, scenePath: string | null, maxSize: number = 512) => {
    if (!scenePath) {
      return { ok: false, error: 'No scene selected' };
    }

    const resolvedScene = path.resolve(scenePath);
    const resolvedImage = path.resolve(imagePath);
    if (!resolvedImage.startsWith(resolvedScene)) {
      return { ok: false, error: 'Invalid image path' };
    }

    const isSegmentation = resolvedImage.includes(`${path.sep}segmentation${path.sep}`);
    const cacheBase = isSegmentation
      ? path.join(resolvedScene, 'segmentation', '.thumbs')
      : path.join(resolvedScene, 'images', '.thumbs');

    const hash = createHash('sha1').update(resolvedImage).digest('hex');
    const size = Math.max(64, Math.min(1024, Math.floor(maxSize)));
    const thumbPath = path.join(cacheBase, `${hash}-${size}.png`);

    try {
      const [sourceStats, thumbStats] = await Promise.all([
        fs.promises.stat(resolvedImage),
        fs.promises.stat(thumbPath).catch(() => null),
      ]);
      if (thumbStats && thumbStats.mtimeMs >= sourceStats.mtimeMs) {
        return { ok: true, thumbnailPath: thumbPath };
      }
    } catch (error) {
      return { ok: false, error: error instanceof Error ? error.message : 'Failed to stat image' };
    }

    try {
      await fs.promises.mkdir(cacheBase, { recursive: true });
      const image = nativeImage.createFromPath(resolvedImage);
      if (image.isEmpty()) {
        return { ok: false, error: 'Failed to load image' };
      }
      const { width, height } = image.getSize();
      const scale = width >= height ? size / Math.max(width, 1) : size / Math.max(height, 1);
      const resized = image.resize({
        width: Math.max(1, Math.round(width * scale)),
        height: Math.max(1, Math.round(height * scale)),
        quality: 'good',
      });
      await fs.promises.writeFile(thumbPath, resized.toPNG());
      return { ok: true, thumbnailPath: thumbPath };
    } catch (error) {
      return { ok: false, error: error instanceof Error ? error.message : 'Failed to create thumbnail' };
    }
  }
);

// Chat IPC Handlers for FastAPI communication
interface ChatResponse {
  message?: string;
  content?: string;
  error?: string;
  command?: {
    type: string;
    action: string;
    params?: Record<string, unknown>;
  };
}

// Send message to FastAPI backend
ipcMain.handle('chat:sendMessage', async (_event, message: string, endpoint: string = 'http://localhost:8000'): Promise<ChatResponse> => {
  try {
    // Use Node's native fetch (available in Electron 22+)
    const response = await fetch(`${endpoint}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ message }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json() as ChatResponse;
    return data;
  } catch (error) {
    console.error('Error sending chat message:', error);
    return {
      error: error instanceof Error ? error.message : 'Failed to connect to backend',
    };
  }
});
