import { app, BrowserWindow, ipcMain, dialog, protocol, session, crashReporter } from 'electron';
import * as fs from 'fs';
import * as path from 'path';
import http from "http";
import { spawn, ChildProcessWithoutNullStreams } from "child_process";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// --- ADD THIS BLOCK AT THE TOP ---
console.log('--- [MAIN PROCESS] SCRIPT START ---');
try {
  console.log(`[Main] __dirname: ${__dirname}`);
  console.log(`[Main] __filename: ${__filename}`);
} catch (e) {
  console.log(`[Main] __dirname or __filename is not defined at top level.`);
}
console.log(`[Main] !app.isPackaged: ${!app.isPackaged}`);
// --- END BLOCK ---

const enableVerboseLogging = process.env.ELECTRON_VERBOSE_LOGGING === '1';
if (enableVerboseLogging) {
  app.commandLine.appendSwitch('enable-logging');
  app.commandLine.appendSwitch('v', '1');
  console.log('[Main] Verbose logging enabled via ELECTRON_VERBOSE_LOGGING=1');
}

process.on('uncaughtException', (error) => {
  console.error('[Main] uncaughtException:', error);
});

process.on('unhandledRejection', (reason) => {
  console.error('[Main] unhandledRejection:', reason);
});

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  const isDev = !app.isPackaged;

  // --- REPLACE YOUR EXISTING DEBUG BLOCK WITH THIS ---
  console.log('--- [MAIN PROCESS] CREATING WINDOW ---');
  
  console.log('--- [MAIN PROCESS] DUMPING ENV VARS ---');
  console.log(`[Main] process.env.PORT: ${process.env.PORT}`);
  console.log(`[Main] process.env.WEBPACK_DEV_SERVER_PORT: ${process.env.WEBPACK_DEV_SERVER_PORT}`);
  console.log(`[Main] process.env.WEBPACK_DEV_SERVER_URL: ${process.env.WEBPACK_DEV_SERVER_URL}`);
  
  console.log(`[Main] isDev: ${isDev}`);
  console.log(`[Main] MAIN_WINDOW_WEBPACK_ENTRY: ${MAIN_WINDOW_WEBPACK_ENTRY}`);
  console.log(`[Main] MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: ${MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY}`);

  const webPreferences = {
    preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    contextIsolation: true,
    sandbox: false,
    nodeIntegration: false,
    nodeIntegrationInWorker: false,
    webSecurity: false, // Just for development; relaxes CORS and CSP
  };

  console.log('[Main] Final webPreferences:');
  console.log(JSON.stringify(webPreferences, null, 2));
  // --- END BLOCK ---

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 720,
    width: 1680,
    webPreferences, // <-- Use the new object here
  });

  // and load the index.html of the app.
  let entryUrl = MAIN_WINDOW_WEBPACK_ENTRY;
  // DEBUG: This override was causing issues. Don't fight forge.
  // if (entryUrl.includes('localhost:3000')) {
  //   console.warn('[Main] Detected legacy dev server on port 3000; defaulting to webpack dev server on 9000.');
  //   entryUrl = entryUrl.replace('localhost:3000', 'localhost:9000');
  // }

// Manually specify the URL to load
// const entryUrl = 'http://localhost:9000/main_window/index.html';
// const entryUrl = 'http://localhost:9000';
// const entryUrl = 'http://localhost:9000/main_window';
// const entryUrl = 'http://localhost:9000/main_window.html';

  // Debug log for URL being loaded
  console.log('[Main] will load URL', entryUrl);
  console.log('[Main] ELECTRON_START_URL', process.env.ELECTRON_START_URL);
  mainWindow.loadURL(entryUrl);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// Register protocols as privileged before app is ready
protocol.registerSchemesAsPrivileged([
  {
    scheme: 'safe-file',
    privileges: {
      bypassCSP: true,
      supportFetchAPI: true,
      corsEnabled: true,
      standard: true,
      secure: true,
    },
  },
  {
    scheme: 'file',
    privileges: {
      bypassCSP: true,
      supportFetchAPI: true,
      corsEnabled: true,
      standard: true,
      secure: true,
    },
  },
]);

// Register custom protocol to serve local files
app.whenReady().then(() => {
  // --- ADD THIS LOG ---
  console.log('[Main] app.whenReady(): Registering file protocols.');
  // --- END LOG ---

  if (enableVerboseLogging) {
    crashReporter.start({
      uploadToServer: false,
      compress: false,
    });
    console.log(`[Main] crashReporter started. crashDumps: ${app.getPath('crashDumps')}`);
  }

  const s = session.defaultSession;

  // Log current headers (optional)
  s.webRequest.onHeadersReceived((details, callback) => {
    const rh = details.responseHeaders || {};
    const key = Object.keys(rh).find(k => k.toLowerCase() === 'content-security-policy');

    // DEV-ONLY: replace CSP for localhost dev servers
    try {
      const u = new URL(details.url);
      if (u.hostname === 'localhost' || u.hostname === '127.0.0.1') {
        rh['Content-Security-Policy'] = [[
          "default-src 'self' data: blob: 'unsafe-inline' 'unsafe-eval'",
          "script-src 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval'",
          "style-src 'self' 'unsafe-inline'",
          "img-src 'self' data: blob: http://localhost:* http://127.0.0.1:*",

          "font-src 'self' data:",
          "connect-src * ws://* http://* https://*",
          "worker-src 'self' blob:",
          "object-src 'none'"
        ].join('; ')];
      }
    } catch {}

    callback({ responseHeaders: rh });
  });


  // Register the safe-file protocol
  const safeFileUrlToPath = (requestUrl: string): string => {
    try {
      const parsed = new URL(requestUrl);
      const hostname = parsed.hostname;
      let filePath = decodeURIComponent(parsed.pathname);
      if (process.platform === 'win32') {
        if (hostname && hostname.length === 1) {
          filePath = `${hostname.toUpperCase()}:${filePath}`;
        } else if (hostname && !/^\/[a-zA-Z]:\//.test(filePath)) {
          filePath = `//${hostname}${filePath}`;
        }
        if (/^\/[a-zA-Z]:\//.test(filePath)) {
          filePath = filePath.slice(1);
        }
        filePath = filePath.replace(/\//g, '\\');
      }
      return filePath;
    } catch {
      let filePath = requestUrl.replace(/^safe-file:\/\//, '');
      filePath = decodeURIComponent(filePath);
      if (process.platform === 'win32') {
        if (/^\/[a-zA-Z]:\//.test(filePath)) {
          filePath = filePath.slice(1);
        }
        filePath = filePath.replace(/\//g, '\\');
      }
      return filePath;
    }
  };

  protocol.registerFileProtocol('safe-file', (request, callback) => {
    const url = safeFileUrlToPath(request.url);
    try {
      return callback(url);
    } catch (error) {
      console.error('Error loading file:', error);
      return callback({ error: -2 }); // net::FAILED
    }
  });

  // Register the file protocol
  protocol.registerFileProtocol('file', (request, callback) => {
    const url = request.url.replace('file://', '');
    try {
      return callback(decodeURIComponent(url));
    } catch (error) {
      console.error('Error loading file:', error);
      return callback({ error: -2 }); // net::FAILED
    }
  });

  createWindow();
  
});

app.on('render-process-gone', (_event, _webContents, details) => {
  console.error('[Main] render-process-gone:', details);
});

app.on('child-process-gone', (_event, details) => {
  console.error('[Main] child-process-gone:', details);
});

app.on('gpu-process-crashed', (_event, killed) => {
  console.error('[Main] gpu-process-crashed. killed:', killed);
});

app.on('web-contents-created', (_event, contents) => {
  contents.on('did-fail-load', (_e, errorCode, errorDesc, validatedURL) => {
    console.error('[Main] did-fail-load:', { errorCode, errorDesc, validatedURL });
  });

  contents.on('render-process-gone', (_e, details) => {
    console.error('[Main] webContents render-process-gone:', details);
  });

  contents.on('unresponsive', () => {
    console.error('[Main] webContents unresponsive');
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// IPC Handlers for File System Operations
interface FileInfo {
  name: string;
  path: string;
  isDirectory: boolean;
  size?: number;
  modified?: Date;
}

function getReportsDir(scenePath: string): string {
  return path.join(scenePath, 'reports');
}

function getMeasurementsFilePath(scenePath: string): string {
  return path.join(getReportsDir(scenePath), 'measurements.json');
}

function getSnapshotPath(scenePath: string, measurementId: string): string {
  return path.join(getReportsDir(scenePath), 'snapshots', `measurement-${measurementId}.png`);
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.promises.access(filePath);
    return true;
  } catch {
    return false;
  }
}

ipcMain.handle('app:getPath', () => app.getAppPath());

ipcMain.handle('path:join', (_event, parts: string[]) => path.join(...parts));

// Open directory picker dialog
ipcMain.handle('dialog:openDirectory', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openDirectory']
  });

  if (result.canceled || result.filePaths.length === 0) {
    return null;
  }

  return result.filePaths[0];
});

// Open GLB file picker dialog
ipcMain.handle('dialog:openGLBFile', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [
      { name: '3D Models', extensions: ['glb'] }
    ]
  });

  if (result.canceled || result.filePaths.length === 0) {
    return null;
  }

  return result.filePaths[0];
});

// Read directory contents
ipcMain.handle('fs:readDirectory', async (_event, dirPath: string): Promise<FileInfo[]> => {
  try {
    const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });

    const fileInfos: FileInfo[] = await Promise.all(
      entries.map(async (entry) => {
        const fullPath = path.join(dirPath, entry.name);
        const stats = await fs.promises.stat(fullPath);

        return {
          name: entry.name,
          path: fullPath,
          isDirectory: entry.isDirectory(),
          size: stats.size,
          modified: stats.mtime
        };
      })
    );

    // Sort: directories first, then files, alphabetically
    return fileInfos.sort((a, b) => {
      if (a.isDirectory === b.isDirectory) {
        return a.name.localeCompare(b.name);
      }
      return a.isDirectory ? -1 : 1;
    });
  } catch (error) {
    console.error('Error reading directory:', error);
    return [];
  }
});

// Get file stats
ipcMain.handle('fs:getStats', async (_event, filePath: string) => {
  try {
    const stats = await fs.promises.stat(filePath);
    return {
      size: stats.size,
      isDirectory: stats.isDirectory(),
      isFile: stats.isFile(),
      modified: stats.mtime,
      created: stats.birthtime
    };
  } catch (error) {
    console.error('Error getting file stats:', error);
    return null;
  }
});

// Check if a directory is a scene folder
ipcMain.handle('fs:checkSceneFolder', async (_event, dirPath: string): Promise<boolean> => {
  try {
    const entries = await fs.promises.readdir(dirPath);
    const folderName = path.basename(dirPath);

    // Required files
    const requiredFiles = [
      'metadata.json',
      'point_cloud.glb',
      // 'point_cloud.ply',
      'camera_extrinsics.npy',
      // 'pose_encoding.npy',
      'camera_intrinsics.npy'
    ];

    const entriesSet = new Set(entries);

    // Verify required files exist
    const hasAllRequired = requiredFiles.every(file => entriesSet.has(file));
    if (!hasAllRequired) {
      return false;
    }

    // Check for images directory
    if (!entriesSet.has('images')) {
      return false;
    }

    const imagesPath = path.join(dirPath, 'images');
    const imagesStat = await fs.promises.stat(imagesPath);
    if (!imagesStat.isDirectory()) {
      return false;
    }

    return true;
  } catch (error) {
    console.error('Error checking scene folder:', error);
    return false;
  }
});

// Get Downloads folder path
ipcMain.handle('fs:getDownloadsPath', async (): Promise<string | null> => {
  try {
    const downloadsPath = app.getPath('downloads');
    // Check if the directory exists
    await fs.promises.access(downloadsPath);
    return downloadsPath;
  } catch (error) {
    console.error('Error getting downloads path:', error);
    return null;
  }
});

// Get PDF path from scene folder path
ipcMain.handle('fs:getScenePDFPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const folderName = path.basename(scenePath);
    const pdfPath = path.join(scenePath, `${folderName}.pdf`);

    // Verify the file exists
    await fs.promises.access(pdfPath);
    return pdfPath;
  } catch (error) {
    console.error('Error getting scene PDF path:', error);
    return null;
  }
});

// Get GLB path from scene folder path
ipcMain.handle('fs:getSceneGLBPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const preferredGlb = path.join(scenePath, 'point_cloud.glb');
    const fallbackGlb = path.join(scenePath, 'scene.glb');
    const glbPath = (await fileExists(preferredGlb)) ? preferredGlb : fallbackGlb;

    // Verify the file exists
    await fs.promises.access(glbPath);
    return glbPath;
  } catch (error) {
    console.error('Error getting scene GLB path:', error);
    return null;
  }
});

// Get QA pairs path from scene folder path
ipcMain.handle('fs:getSceneQAPairsPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const qaPairsPath = path.join(scenePath, 'qa_pairs.json');

    // Verify the file exists
    await fs.promises.access(qaPairsPath);
    return qaPairsPath;
  } catch (error) {
    console.error('Error getting scene QA pairs path:', error);
    return null;
  }
});

// Read and parse QA pairs JSON file
ipcMain.handle('fs:readQAPairs', async (_event, qaPairsPath: string): Promise<any[] | null> => {
  try {
    const fileContent = await fs.promises.readFile(qaPairsPath, 'utf-8');
    const qaPairs = JSON.parse(fileContent);
    return qaPairs;
  } catch (error) {
    console.error('Error reading QA pairs file:', error);
    return null;
  }
});

// Get scene graph JSON file path
ipcMain.handle('fs:getSceneGraphPath', async (_event, scenePath: string): Promise<string | null> => {
  try {
    const sceneGraphPath = path.join(scenePath, 'scene_graph.json');

    // Verify the file exists
    await fs.promises.access(sceneGraphPath);
    return sceneGraphPath;
  } catch (error) {
    console.error('Error getting scene graph path:', error);
    return null;
  }
});

// Read and parse scene graph JSON file
ipcMain.handle('fs:readSceneGraph', async (_event, sceneGraphPath: string): Promise<any | null> => {
  try {
    const fileContent = await fs.promises.readFile(sceneGraphPath, 'utf-8');
    const sceneGraph = JSON.parse(fileContent);
    return sceneGraph;
  } catch (error) {
    console.error('Error reading scene graph file:', error);
    return null;
  }
});

// Get image file paths from scene folder's images directory
ipcMain.handle('fs:getSceneImages', async (_event, scenePath: string): Promise<string[] | null> => {
  try {
    const imagesDir = path.join(scenePath, 'images');

    // Verify the directory exists
    await fs.promises.access(imagesDir);

    // Read directory contents
    const entries = await fs.promises.readdir(imagesDir, { withFileTypes: true });

    // Filter for image files (png, jpg, jpeg)
    const imageFiles = entries
      .filter(entry => {
        if (!entry.isFile()) return false;
        const ext = path.extname(entry.name).toLowerCase();
        return ['.png', '.jpg', '.jpeg', '.webp', '.tiff'].includes(ext);
      })
      .map(entry => path.join(imagesDir, entry.name))
      .sort((a, b) => a.localeCompare(b));

    return imageFiles;
  } catch (error) {
    console.error('Error getting scene images:', error);
    return null;
  }
});

// Read and parse scene metadata
ipcMain.handle('fs:getSceneMetadata', async (_event, scenePath: string): Promise<any | null> => {
  try {
    const metadataPath = path.join(scenePath, 'metadata.json');
    const fileContent = await fs.promises.readFile(metadataPath, 'utf-8');
    return JSON.parse(fileContent);
  } catch (error) {
    console.error('Error reading scene metadata:', error);
    return null;
  }
});

// Load measurements for a scene (from userData/reports)
ipcMain.handle('fs:loadMeasurements', async (_event, scenePath: string): Promise<any[] | null> => {
  try {
    const filePath = getMeasurementsFilePath(scenePath);
    try {
      await fs.promises.access(filePath);
    } catch {
      return [];
    }
    const fileContent = await fs.promises.readFile(filePath, 'utf-8');
    const payload = JSON.parse(fileContent);
    if (payload && Array.isArray(payload.measurements)) {
      return payload.measurements;
    }
    return [];
  } catch (error) {
    console.error('Error loading measurements:', error);
    return null;
  }
});

// Save measurements for a scene (to userData/reports)
ipcMain.handle('fs:saveMeasurements', async (_event, scenePath: string, measurements: any[]): Promise<string | null> => {
  try {
    const filePath = getMeasurementsFilePath(scenePath);
    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
    const payload = {
      scenePath,
      updatedAt: new Date().toISOString(),
      measurements,
    };
    await fs.promises.writeFile(filePath, JSON.stringify(payload, null, 2), 'utf-8');
    return filePath;
  } catch (error) {
    console.error('Error saving measurements:', error);
    return null;
  }
});

ipcMain.handle('fs:saveMeasurementSnapshot', async (_event, scenePath: string, measurementId: string, dataUrl: string): Promise<string | null> => {
  try {
    const match = dataUrl.match(/^data:image\/png;base64,(.+)$/);
    if (!match) {
      throw new Error('Invalid PNG data URL');
    }
    const buffer = Buffer.from(match[1], 'base64');
    const filePath = getSnapshotPath(scenePath, measurementId);
    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
    await fs.promises.writeFile(filePath, buffer);
    return filePath;
  } catch (error) {
    console.error('Error saving measurement snapshot:', error);
    return null;
  }
});

ipcMain.handle('fs:deleteMeasurementSnapshot', async (_event, scenePath: string, measurementId: string): Promise<boolean> => {
  try {
    const filePath = getSnapshotPath(scenePath, measurementId);
    try {
      await fs.promises.unlink(filePath);
    } catch (error: any) {
      if (error?.code !== 'ENOENT') {
        throw error;
      }
    }
    return true;
  } catch (error) {
    console.error('Error deleting measurement snapshot:', error);
    return false;
  }
});

// Read binary file as Buffer
ipcMain.handle('fs:readFileBuffer', async (_event, filePath: string): Promise<Buffer | null> => {
  try {
    const data = await fs.promises.readFile(filePath);

    // --- Start Debug Logs ---
    if (filePath.endsWith('pose_encoding.npy')) {
        console.log(`[Main Process readFileBuffer] Read file: ${filePath}`);
        console.log(`[Main Process readFileBuffer] Buffer instance: ${data instanceof Buffer}`);
        console.log(`[Main Process readFileBuffer] Buffer length: ${data.length}`);
        const firstBytes = data.slice(0, 10);
        console.log(`[Main Process readFileBuffer] Buffer first 10 bytes (hex): ${firstBytes.toString('hex')}`);
         try {
           const firstChars = firstBytes.toString('latin1');
           console.log(`[Main Process readFileBuffer] Buffer first 10 chars (latin1): "${firstChars}"`);
         } catch (e) {
           console.error('[Main Process readFileBuffer] Error decoding first bytes as latin1:', e);
         }
    }
    // --- End Debug Logs ---

    return data;
  } catch (error) {
    console.error(`Error reading binary file: ${filePath}`, error);
    return null;
  }
});

// Chat IPC Handlers for FastAPI communication
interface ChatResponse {
  message?: string;
  content?: string;
  error?: string;
  command?: {
    type: string;
    action: string;
    params?: Record<string, unknown>;
  };
}

// Send message to FastAPI backend
ipcMain.handle('chat:sendMessage', async (_event, message: string, endpoint: string = 'http://localhost:8000'): Promise<ChatResponse> => {
  try {
    // Use Node's native fetch (available in Electron 22+)
    const response = await fetch(`${endpoint}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ message }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json() as ChatResponse;
    return data;
  } catch (error) {
    console.error('Error sending chat message:', error);
    return {
      error: error instanceof Error ? error.message : 'Failed to connect to backend',
    };
  }
});

// RTSP Streaming Handlers
let mjpegServer: http.Server | null = null;
let ffmpegProc: ReturnType<typeof spawn> | null = null;
let latestJpeg: Buffer | null = null;

// Start a tiny HTTP server that serves MJPEG at /stream.mjpg
function ensureMjpegServer(port = 9100) {
  if (mjpegServer) return port;

  mjpegServer = http.createServer((req, res) => {
    const reqUrl = new URL(req.url || "/", "http://localhost");
    const pathname = reqUrl.pathname;

    if (pathname === "/latest.jpg") {
      if (!latestJpeg) {
        res.writeHead(204);
        res.end();
        return;
      }

      res.writeHead(200, {
        "Cache-Control": "no-cache, no-store, must-revalidate",
        "Pragma": "no-cache",
        "Expires": "0",
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "image/jpeg",
      });
      res.end(latestJpeg);
      return;
    }

    if (pathname !== "/stream.mjpg") {
      res.writeHead(404);
      res.end("Not found");
      return;
    }

    res.writeHead(200, {
      "Cache-Control": "no-cache",
      "Pragma": "no-cache",
      "Connection": "close",
      "Access-Control-Allow-Origin": "*",
      "Content-Type": "multipart/x-mixed-replace; boundary=frame",
    });

    const timer = setInterval(() => {
      if (!latestJpeg) return;
      res.write(`--frame\r\nContent-Type: image/jpeg\r\nContent-Length: ${latestJpeg.length}\r\n\r\n`);
      res.write(latestJpeg);
      res.write("\r\n");
    }, 100); // ~10 fps (adjust)

    req.on("close", () => clearInterval(timer));
  });

  mjpegServer.listen(port, "localhost", () => {
    console.log(`[RTSP] MJPEG server on http://localhost:${port}/stream.mjpg`);
    console.log(`[RTSP] Latest frame on http://localhost:${port}/latest.jpg`);
  });


  return port;
}

function stopFfmpeg() {
  if (ffmpegProc) {
    try { ffmpegProc.kill("SIGTERM"); } catch {}
    ffmpegProc = null;
  }
  latestJpeg = null;
}

function startRtspToMjpeg(rtspUrl: string) {
  stopFfmpeg();

  // FFmpeg outputs a stream of JPEG frames to stdout (image2pipe)
  const args = [
    "-rtsp_transport", "tcp",
    "-i", rtspUrl,
    "-an",
    "-vf", "scale=1280:-1,fps=10",
    "-q:v", "5",
    "-f", "image2pipe",
    "-vcodec", "mjpeg",
    "pipe:1",
  ];

  console.log("[RTSP] starting ffmpeg:", "ffmpeg", args.join(" "));
  ffmpegProc = spawn("ffmpeg", args, { stdio: ["ignore", "pipe", "pipe"] });

  // Parse JPEG frames from stdout by looking for JPEG start/end markers
  let buf = Buffer.alloc(0);
  ffmpegProc.stdout.on("data", (chunk: Buffer) => {
    buf = Buffer.concat([buf, chunk]);

    while (true) {
      const start = buf.indexOf(Buffer.from([0xff, 0xd8])); // JPEG SOI
      const end = buf.indexOf(Buffer.from([0xff, 0xd9]));   // JPEG EOI
      if (start === -1 || end === -1 || end < start) break;

      const frame = buf.slice(start, end + 2);
      latestJpeg = frame;
      buf = buf.slice(end + 2);
    }
  });

  ffmpegProc.stderr.on("data", (d: Buffer) => {
    // Uncomment if you want logs:
    // console.log("[FFMPEG]", d.toString());
  });

  ffmpegProc.on("close", (code) => {
    console.log("[RTSP] ffmpeg exited:", code);
    ffmpegProc = null;
  });

  ffmpegProc.on("error", (err) => {
    console.error("[RTSP] ffmpeg spawn error:", err);
    ffmpegProc = null;
  });
}

// IPC for renderer to start/stop
ipcMain.handle("rtsp:start", async (_evt, url: string) => {
  const port = ensureMjpegServer(9100);
  startRtspToMjpeg(url);
  return { mjpegUrl: `http://localhost:${port}/stream.mjpg` };
});

ipcMain.handle("rtsp:stop", async () => {
  stopFfmpeg();
  return true;
});
